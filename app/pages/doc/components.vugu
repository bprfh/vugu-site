<div>
                    <p>
                      <strong>Components are individual files which are used to organize your user interface code.</strong>
                      Each component lives in a .vugu file.  Each .vugu file is processed to produce 
                      a .go file.  Like all Go code, each directory is a package and you may add 
                      additional .go files to it and use them as part of your component.
                      Vugu does some 
                      code generation, but otherwise does not interfere with the regular Go build 
                      process at all.  By default, code generated files end with <em>_vgen.go</em>.
                    </p>

                    <!-- <p>
                      Under the hood, components implement the 
                      <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#ComponentType">ComponentType</a> 
                      interface.  Although this is 
                      unimportant to most developers as the code generator does the work to 
                      implement it based on your .vugu file.
                    </p> -->

                    <p>
                      By default, the component named <strong>root</strong> (and thus living in root.vugu) <strong>is the top 
                      level component</strong> and is rendered just inside the <code>&lt;body></code> tag on your page.
                      In this case, there is only one instance of your root component, which is created in your <code>main()</code> function.
                      (If you've followed the 
                      <a href="/doc/files/start">Getting Started</a>
                      instructions you can find this code in main_wasm.go)
                    </p>

                    <p>
                      Things get interesting when we introduce the idea of <strong>multiple components</strong> into an application.
                      Each component goes in its own .vugu file.
                    </p>

                    <p>
                      It's important to remember that under the hood, components are just Go structs.
                      All component references are resolved at compile-time.  There is intentionally
                      as little magic involved as possible.  In fact, components are really just implementations
                      of the <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#Builder">Builder</a>
                      interface and simply provide a <code>Build</code> method with HTML nodes they output.
                    </p>

                    <h2>Static Component References</h2>

                    <p>
                      One component can include a <strong>tag that indicates the name of
                      a component struct to use.</strong>.  
                      When this happens, it says than an instance 
                      of this other component should be created.  Let's look at an example:
                    </p>

<div vg-html='codefmt.Show("html",`<!-- root.vugu -->
<div class="root">
    <ul>
      <main:MyLine FileName="example.txt" :LineNumber="rand.Int63n(100)" ></main:MyLine>
    </ul>
</div>

<script type="application/x-go">
import "math/rand"
</script>
`)'></div>

<div vg-html='codefmt.Show("html",`<!-- my-line.vugu -->

<li class="my-line">
  <strong vg-html=&apos;c.FileName&apos;></strong>:<span vg-html=&apos;c.LineNumber&apos;></span>
</li>

<script type="application/x-go">
type MyLine struct {
    FileName string `+"`"+`vugu:"data"`+"`"+`
    LineNumber int  `+"`"+`vugu:"data"`+"`"+`
}
</script>`)'></div>

                      <p>In this case the <code>&lt;main:MyLine></code> tag gets replaced with the <code>&lt;li></code> tag and its contents as 
                        rendered by the MyLine component.  The reference is emitted directly into the code generated file and resolved at Go compile time.
                      </p>

                      <p><code>main</code> is the name of the package.  The name of the current package ("main" or otherwise) is removed
                      in the generated code, but otherwise all package names are regular Go references.  Import statements are required
                      in order to access components in other packages.</p>

                      <p>
                        As shown in the example, HTML attributes starting with a capital letter correspond to struct field assignments.
                        Attributes with a colon (<code>:</code>)
                        will be evaluated as Go code and then the result used as-is (not converted in any way). 
                        This allows you to pass arbitrarily complex data, or pointers, etc. into components when needed.
                      </p>

                      <!-- <p>
                        The <code>NewData</code> method on the component type is responsible for reading the props 
                        passed into it and populating the data struct for this component instance.
                        (This method is part of satisfying the
                         <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#ComponentType">ComponentType</a> interface.)
                      </p> -->

                      <p>
                        Components can be instantiated as many times as needed. Each one causes a new instance 
                        to be created.  Like so:
                      </p>

<div vg-html='codefmt.Show("html",`<!-- root.vugu -->

<div class="root">
    <ul>
      <main:MyLine vg-for=&apos;i := 0; i < 10; i++&apos; 
        FileName="example.txt" :LineNumber="i" ></main:MyLine>
    </ul>
</div>
`)'></div>

                      <p>Components used in this way also support additional features including dynamic properties, as follows:</p>

<div vg-html='codefmt.Show("html",`<pkg:Comp 
    StringField="some string"
    :DynamicField=&apos;/* some go expression */ 123.0&apos;
    stringAttrMapValue="some string"
    :dynamicAttrMapValue=&apos;/* some go expression */ 123.0&apos;
    ></pkg:Comp>
`)'></div>
                      <ul>
                        <li><code>pkg</code> is the package name - it must correspond to an import statement 
                          or be the same as the current package.</li>
                        <li><code>Comp</code> is the name of the component struct.  
                          No mangling is performed on it, or any of the fields mentioned below.
                        It should be an exported type (start with a capital letter).</li>
                        <li><code>StringField</code> is assigned as a regular Go struct field 
                          using the string "some string"</li>
                        <li><code>DynamicField</code> is assigned as a regular Go struct field but 
                          <code>/* some go expression */ 123.0</code> is emitted directly into the 
                          code-generated file and thus evaluated as Go code.</li>
                        <li><code>stringAttrMapValue</code> (lower-case first letter) is assigned as a 
                          key of to a field that you must declare as <code>AttrMap map[string]interface{}</code> - 
                          this allows you to accept arbitrary values as component input, or not.</li>
                        <li><code>dynamicAttrMapValue</code> (lower-case first letter) works like 
                          <code>stringAttrMapValue</code> but is evaluated as Go code instead of a static string.</li>
                      </ul>

                      <p>The <code>vg-key</code> attribute can also be specified on a component reference to indicate an additional value which 
                      should be used for caching purposes.  Generally this is a key used in a loop iterator.  Note that loops will automatically 
                      select the key from the <nobr><code>vg-for</code>,</nobr> but you can override what is used for caching purposes by specifying 
                      <nobr><code>vg-key</code></nobr> on your component reference.</p>

                      <!-- <div class="alert alert-warning" role="alert">
                        <i class="icon-alert-circle"></i>
                        <h4 class="fs-22">Please Note</h4>
                        <p>
                          The syntax for custom component tags will likely be changed from
                          <code>pkg:Comp</code> to <code>pkg-Comp</code>.
                          The rationale is that using a colon creates an ambiguity between components
                          and HTML namespaces such as <code>svg</code>, and since component types are 
                          always exported (start with a capital letter), this makes <code>pkg-Comp</code> unambiguous 
                          from other customs tags which would be all lower case.
                          If this change is made both syntaxes will be supported for a while in 
                          order to ease transition.
                        </p>
                      </div> -->
              
                      <!-- <p>  TODO: update this
                        Vugu needs a way to determine, when re-rendering the HTML, which components are the same and which 
                        are now different and should be re-created.  This is determined by calling 
                        <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#ComputeHash">ComputeHash</a>
                        on the attributes (including dynamically evaluted/colon prefixed ones after evaluation) and if the hash 
                        is different a new instance is created.  If it's the same, the same one is re-used.
                      </p> -->
                      
                      <p>
                        Any component can include any other component. But if components include each other 
                        in a loop the behavior is undefined (but I can promise you it won't be good).
                      </p>

                    <!-- <div class="alert alert-warning" role="alert">
                        <i class="icon-alert-circle"></i>
                        <h4 class="fs-22">Note</h4>
                        <p>By default components register themselves in an <code>init()</code> function by calling 
                          <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#RegisterComponentType">RegisterComponentType</a>.
                          And by default in <code>main()</code> all registered components are retrieved and made available.
                          So you can place <code>import _ "your/package"</code> in any file and if that package contains components 
                          they will be available for use.  This behavior can also easily be changed by modifying the appropriate 
                          behavior in main_wasm.go, in case you need more control over what components are available
                          under what names.</p>
                      </div> -->

                      <h2>Dynamic Component References</h2>

                      <p>Component references can also be done dynamically based on an arbitrary Go expression.  This is done with 
                        a <code>&lt;vg-comp expr="">&lt;vg-comp></code> tag, and the expression must 
                        resolve to a type compatible with <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#Builder">vugu.Builder</a>.
                        This allows you to instantiate a component in your own Go code and reference it directly during render.  Example:
                      </p>

<div vg-html='codefmt.Show("html",`<!-- root.vugu -->
<div>
    <vg-comp expr="c.MyChildComp"></vg-comp>
</div>

<script type="application/x-go">

type Root struct {
    MyChildComp vugu.Builder
}

func (c *Root) BeforeBuild() {
    if c.MyChildComp == nil {
        c.MyChildComp = &someother.ComponentHere{}
    }
}

</script>
`)'></div>

                      <h2>BeforeBuild()</h2>

                      <p>For a component, after any field assignments are done and before the actual virtual DOM building occurs, the 
                        <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#BeforeBuilder">BeforeBuild()</a> method is called on a component if it exists.</p>

                      <p>This is for use in implementing "computed fields" (to use Vue's terminology), and doing any precomputation prior to building.</p>

                      <h2 id="modification-tracking">Modification Tracking</h2>

                      <p>Modification tracking is done with <code>ModTracker</code>, it is used internally, you won't need to instantiate it yourself.</p>
                      
                      <p>ModTracker determines "changed" from one render pass to the next based on these rules:</p>
                      
                      <ul>
                      <li><strong>Component (and other structs) fields are traversed by calling <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#ModCheckAll">ModCheckAll</a> on each with the struct tag <code>`vugu:"data"`</code>.</strong>  Any struct fields used as component input should be tagged as such, or you must implement the 
                        <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#ModChecker">ModChecker</a>
                        interface.  "Computed fields", populated during <code>BeforeBuild()</code> should generally not be tagged like this.</li>
                      <li><strong>Then modification checking continues to traverse based on these rules:</strong></li>
                      <li><strong>For values implementing the <code>ModChecker</code> interface,</strong> the <code>ModCheck</code> method will be called.</li>
                      <li><strong>All values passed should be pointers</strong> to the types described below.</li>
                      <li><strong>Single-value primitive types</strong> are supported.  </li>
                      <li><strong>Arrays and slices of supported types are supported,</strong> their length is compared as well as a pointer to each member.</li>
                      <li><strong>As a special case, []byte is treated like a string.</strong></li>
                      <li><strong>Maps are not supported</strong> at this time.</li>
                      <li><strong>Other weird and wonderful things like channels and funcs are not supported.</strong></li>
                      <li><strong>Passing an unsupported type will result in a panic.</strong></li>
                      </ul>

                      <p>
                      The point of all this is that <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#ModTracker">ModTracker</a> will scan your component and follow the graph of objects to determine if it is "modified" before re-rendering.  The 
                      <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#ModChecker">ModChecker</a> interface (and if you're looking at that, have a look at <a target="_blank" href="https://godoc.org/github.com/vugu/vugu#ModCounter">ModCounter</a> as a simple implementation) allows developers to customize how modification tracking is done, for when the graph of objects gets too large and things get slow.
                      </p>


</div>

<script type="application/x-go">

import "github.com/vugu/vugu-site/app/codefmt"

type Components struct {}

func (c *Components) Title() string { return "Using Components" }
func (c *Components) MetaDescription() string { return "Components are individual files which are used to organize your user interface code. Each component lives in a .vugu file. Each .vugu file is processed to produce a .go file." }

</script>